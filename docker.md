## 基本概念

### 简介
Docker是一个用于 **构建(bulid)** **运行(run)** **传送(share)** 应用程序的平台

可以将应用程序打包成一个容器，然后发布到任
何地方。

常见打包包括: 操作系统, 运行时环境, 依赖库, 应用程序, 配置文件,启动命令等。

这样就解决了环境不一致的问题，使得应用程序可以在任何地方运行。

### 为什么使用Docker

- 比如, 现在有一个流行开发环境: 
    - 前端: vue
    - 后端: SpringBoot
    - 数据库: MySQL
    - 缓存: Redis
    - 负载均衡: Nginx
    - 等等
 
- 所需开发环境需要
    - 安装NodeJS环境
    - 安装npm依赖
    - 安装JDK
    - 安装各种第三方依赖
    - 安装MySQL
    - 环境变量, 启动脚本
    - 配置Redis
    - 配置Nginx
    - 等等

- 重复安装这些环境, 配置这些环境, 会浪费大量时间, 而且很容易出错。

- 使用Docker, 可以将这些环境打包成一个容器, 然后放到任何地方使用

### 与传统虚拟机的区别

- 传统虚拟机(虚拟化Hypervisor)
    - 完整的操作系统
    - 完全隔离
    - 启动慢, 占用资源多, 难以迁移

- Docker和容器是两个不同的概念
    - Docker是容器的一种实现也就是平台, 用于构建,运行,传送容器
    - 容器是一种轻量级的虚拟化(Hypervisor)技术, 也是一个独立的运行环境, 用于运行应用程序

- 两者区别在于
    - 容器是应用程序级别的虚拟化, 而不是操作系统级别的虚拟化
    - 容器共享宿主机的操作系统内核, 而不是像传统虚拟机一样, 每个虚拟机都有自己的操作系统内核
    - 容器启动快, 占用资源少, 易于迁移

### 基本原理和概念

- 体系架构
    - 使用的是`Client-Server`架构, 也就是`C/S`架构, 客户端和服务端分离
    - `Docker client` 和 `Docker Daemon`通过Socket或RESTful API进行通信, 客户端和服务端可以运行在同一台机器, 也可以运行在不同的机器
        - `Docker client`: 用户使用的命令行工具, 用于向Docker Daemon发送请求
        - `Docker Daemon`: 服务端的守护进程, 用于管理镜像, 容器, 网络, 卷等, 处理客户端请求后, 返回结果
            - 守护进程的意思是, 一直在后台运行, 不会退出

- 镜像(Image)
    - 一个只读的模板, 用于创建容器
    - 镜像是一个文件, 包含了应用程序运行所需的所有依赖, 包括操作系统, 运行时环境, 应用程序, 配置文件, 启动命令等
    - 镜像是一个多层文件系统, 每一层都是一个镜像, 通过这种方式, 可以复用镜像, 减少存储空间

- 容器(Container)
    - 一个镜像的运行实例
    - 容器是一个独立的运行环境, 包括了应用程序, 运行时环境, 系统工具, 系统库, 系统配置等
    - 容器是一个独立的进程, 由Docker引擎启动, 运行, 停止, 删除
  
- 仓库(Repository)
    - 用于存储镜像的地方
    - 仓库是一个集中存放镜像的地方, 可以理解为代码仓库
    - 仓库分为公有仓库和私有仓库, 公有仓库是开放的, 任何人都可以下载, 私有仓库是私有的, 只有授权的用户可以下载

### 容器化和Dockerfile

- 容器化(containerization)
    - 将应用程序打包成一个容器, 然后发布到任何地方
    - 容器化的好处是, 可以将应用程序和运行环境打包在一起, 使得应用程序可以在任何地方运行
    - 用法三个步骤: 创建Dockfile, 用Dockerfile构建镜像, 运行容器

- Dockerfile
    - 用于构建镜像的文件
    - Dockerfile是一个文本文件, 包含了一系列命令, 用于构建镜像
    - 通过Dockerfile, 可以将应用程序和运行环境打包在一起, 使得应用程序可以在任何地方运行

## 常用命令

### 日常操作

- `docker version` 查看docker版本
- `docker info` 查看docker系统信息
- `docker --help` 查看docker帮助文档
- `docker [command] --help` 查看docker命令帮助文档
- `docker login/logout` 登录/登出docker仓库

### Dockerfile常用命令

- `FROM` 指定基础镜像
    - 指定基础镜像，必须为 Dockerfile的第⼀条指令
    - 参数: `FROM <镜像名>:<标签>`
    - 例: `FROM node:14-alpine`
        - alpine是一个轻量级的Linux发行版, 适合用于容器

- `ADD` 复制文件
    - ⽤于将⽂件复制到镜像中，源可以是 URL或者本地⽂件，也可以是⼀个压缩⽂件（⾃动解压）
    - 参数: `ADD <源路径> <目标路径>`
    - 例: `ADD package.json /app/`

- `COPY` 复制文件
    - ⽤于将⽂件复制到镜像中，源只能是本地⽂件，不能是 URL 或者压缩⽂件
    - 参数: `COPY <--chown=<user>:<group><源路径> <目标路径>`
        - `--chown=<user>:<group>` 指定⽂件的所属⽤户和组
    - 例: `COPY package.json /app/`

- `RUN` 执⾏命令
    - ⽤于执⾏命令，可以执⾏任何命令，包括安装软件，修改配置等 
    - 参数: `RUN <命令>`
    - 例: `RUN npm install`

- `WORKDIR` ⼯作⽬录
    - ⽤于指定⼯作⽬录，可以使⽤多个 WORKDIR指令，如果使⽤相对路径，则是相对于上⼀条 WORKDIR指令所指定的⽬录
    - 参数: `WORKDIR <⽬录路径>`
    - 例: `WORKDIR /app`

- `ENV` 环境变量
    - ⽤于设置环境变量，可以使⽤多个 ENV指令
    - 参数: `ENV <键> <值>`
    - 参数: `ENV <键1>=<值1> <键2>=<值2> ...`
    - 例: `ENV NODE_ENV production`


- `CMD` 容器启动命令
    - ⽤于指定默认的容器主进程，每个 Dockerfile中只能有⼀条 CMD指令，如果有多条，则只有最后⼀条会⽣效
    - 参数: `CMD <命令> /`
    - 参数: `CMD ["<可执行程序>", "<参数1>", "<参数2>", ...]`
    - 例: `CMD ["npm", "start"]`

- `EXPOSE` 暴露端⼝
    - ⽤于指定容器运⾏时监听的端⼝，可以使⽤多个 EXPOSE指令
    - 参数: `EXPOSE <端⼝>`
    - 例: `EXPOSE 3000`

- `VOLUME` 挂载⽬录
    - ⽤于定义匿名卷（持久化⽬录）
    - 参数: `VOLUME <⽬录路径>`
    - 参数: `VOLUME ["<⽬录路径1>", "<⽬录路径2>", ...]`
    - 例: `VOLUME /app/public`

### 镜像管理

### 容器管理

### 容器运行

### 容器操作

### 网络管理

### 数据卷管理

### 插件管理























## 构建镜像

### 非当前目录构建

- `docker build -t <镜像名>:<标签> <Dockerfile路径>` 构建镜像
    - `-t` 指定镜像名和标签
    - `<Dockerfile路径>` 指定Dockerfile的路径

### 当前目录构建

- `docker build -t <镜像名>:<标签> .` 构建镜像
    - `-t` 指定镜像名和标签
    - `.` 当前目录

### 查看镜像

- `docker images`or `docker images ls`查看镜像

## 运行容器

### 简单运行

- `docker run <镜像名>:<标签>` 运行容器

### 后台运行 && 端口映射 && 指定容器名 && 指定镜像名 运行

- `docker run -d -p <宿主机端口>:<容器端口> --name <容器名> <镜像名>:<标签>` 运行容器
    - `-d` 后台运行
    - `-p` 指定宿主机端口和容器端口的映射
    - `--name` 指定容器名
    - `<镜像名>:<标签>` 指定镜像名和标签


## Docker Compose & Kubernetes

### Docker Compose

- Docker Compose是一个用于定义和运行多容器Docker应用程序的工具
- 通过一个`docker-compose.yml`文件, 定义一组容器, 然后通过`docker-compose`命令, 启动, 停止, 删除这组容器
- 通过`docker-compose`命令, 可以一次性启动多个容器, 而不是一个一个启动
- 运行场景
    - 前端&后端&数据库&缓存&负载均衡等不同容器组成的应用程序
    - 开发环境&测试环境&生产环境等不同环境的应用程序

### Kubernetes

- Kubernetes是一个开源的容器编排引擎, 用于自动化部署, 扩展和管理容器化应用程序
- Kubernetes的特点
    - 自动化部署, 扩展和管理容器化应用程序
    - 自动化容器的调度和负载均衡
    - 自动化容器的健康检查和自愈
    - 自动化容器的扩展和收缩
    - 自动化容器的滚动升级和回滚
    - 自动化容器的配置管理
    - 自动化容器的存储管理
    - 自动化容器的网络管理
    - 自动化容器的安全管理
    - 等等
- 用法
    - 通过`kubectl`命令, 可以管理Kubernetes集群, 包括创建, 删除, 更新, 查询, 扩展, 收缩, 升级, 回滚, 配置, 存储, 网络, 安全等
