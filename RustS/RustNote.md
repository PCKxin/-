## day1 cargo

### cargo 

- rust的包管理工具
- 包管理工具的最大作用就是让用户拿到代码即运行，而不需要去关心依赖的问题

#### 创建新项目

```bash
cargo new project_name
```

#### 编译项目

```bash
cargo build
```

#### 手动运行项目

```bash
./target/debug/project_name
```
- debug 是在debug模式下编译的, 目的是不做任何优化，快速编译，方便调试
- 但是速度会变慢，运行时会占用更多的内存
#### 编译并运行项目

```bash
cargo run
```
- cargo run会自动编译项目，然后运行项目

#### 编译项目并生成可执行文件(高性能编译)

```bash
cargo build --release
```

#### 手动运行可执行文件(高性能编译)

```bash
./target/release/project_name
```

#### 高性能运行编译项目

```bash
cargo run --release
```

#### cargo check

- 当项目越来越大的时候, 编译的时间会越来越长
- 这时候可以使用cargo check来检查代码是否能够编译通过, 而不会真正的编译代码, 这样可以节省很多时间

```bash
cargo check
```

#### cargo update

- 更新依赖

```bash
cargo update
```

#### cargo doc

- 生成文档

```bash
cargo doc
```

#### cargo clean

- 清除编译生成的文件

```bash
cargo clean
```

#### `cargo.toml` & `cargo.lock`

- cargo的核心文件, 所有的活动都是围绕这两个文件进行的
- `cargo.toml`是cargo 特有的项目数据描述文件(配置文件), 用来描述项目的信息, 以及依赖的第三方库
- `cargo.lock`是项目依赖详细清单, 用来锁定依赖的第三方库的版本, 保证项目的稳定性, 一般不用修改, 由cargo自动生成和维护

##### package段落

- 用来描述项目的基本信息

- 例:
```toml
[package]
name = "project_name" # 项目名称
version = "0.1.0" # 版本号
edition = "2021" # rust版本
authors = ["author_name <author_email>"] # 作者信息
```

- cargo.toml中, 主要通过各种段落来描述项目的信息, 以及各种依赖项
    - 基于Rust官方仓库crates.io, 通过版本说明来描述
    - 基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述
    - 基于项目源代码的 git 仓库地址，通过 URL 来描述

##### dependencies段落

- 定义项目依赖
- 使用cargo的最大优势在于, 能够对各种依赖进行统一灵活的管理, 保证项目的稳定性
- 用来描述项目依赖的第三方库

- 例:
```toml
[dependencies]
rand = "0.8.3" # 依赖的第三方库名称和版本号
hammer = { version = "0.5.0"} # 依赖的第三方库名称和版本号
color = { git = "https://github.com/bjz/color-rs" } # 依赖的第三方库名称和版本号
geometry = { path = "crates/geometry" } # 依赖的第三方库名称和版本号
```

##### dev-dependencies段落

- 用来描述项目开发时依赖的第三方库

- 例:
```toml
[dev-dependencies]
rand = "0.8.3" # 依赖的第三方库名称和版本号
hammer = { version = "0.5.0"} # 依赖的第三方库名称和版本号
color = { git = "https://github.com/bjz/color-rs" } # 依赖的第三方库名称和版本号
geometry = { path = "crates/geometry" } # 依赖的第三方库名称和版本号
```


## day2 变量绑定与解构

### 为什么要手动设置变量`可变性`

- 为了保证代码的安全性, rust默认所有的变量都是不可变的
- 如果想要修改变量的值, 需要手动设置变量可变性
    - 通过`mut`关键字来设置变量可变性

在其他大部分语言中, 变量要么是可变的(灵活性), 要么是不可变的(安全性), 但是rust中, 变量可以同时拥有这两个特性, 这是rust的一个非常大的优势

- 可变变量拥有灵活性和高性能(不需要内存拷贝, 只需要修改原来的值)
    - 在使用大型数据结构或者热点代码路径（被大量频繁调用）的情形下, 在同一内存位置更新实例可能比复制并返回新分配的实例要更快
- 不可变变量拥有安全性(不会被修改), 但是性能较低(需要内存拷贝)涉及到了内存对象的再次分配, 并且失去了灵活性
    - 使用较小的数据结构时, 通常创建新的实例并以更具函数式的风格来编写程序, 可能会更容易理解, 所以值得以较低的性能开销来确保代码清晰。

### 变量绑定&可变性

- rust核心原则: 所有权
    - 意思是: 所有的值都有一个变量绑定, 这个绑定是唯一的

- 变量绑定是将一个值绑定到一个变量上
- 变量绑定是通过`let`关键字来实现的, 不可变绑定是默认的绑定方式
- 可变绑定是通过`mut`关键字来实现的

- 不可变绑定:
```rust
fn main() {
    let x = 5; // 将5绑定到变量x
    // 不可变绑定, 不能修改
    x = 6; // error[E0384]: cannot assign twice to immutable variable `x`
}
```

- 可变绑定:
```rust
fn main() {
    let mut x = 5; // 将5绑定到变量x
    // 可变绑定, 可以修改
    x = 6;
    println!("{}", x); // 6
}
```

### 使用下划线开头忽略未使用的变量

- rust中, 变量绑定不使用会触发警告, 这时候就可以使用下划线开头来忽略未使用的变量, 从而避免警告

```rust
fn main() {
    let _x = 5; 
    println!("{}", _x); // 5
}
```

### 解构

- 解构是将一个复合的值分解成其组成部分的过程

#### 解构式赋值

- 解构式赋值是将一个复合的值分解成其组成部分的过程, 并将这些值绑定到变量上
- 需要注意的是，使用 += 的赋值语句还不支持解构式赋值。

- 元组、切片和结构体都支持解构式赋值
- 例:
```rust
fn main() {
    let (x, y) = (1, 2); // 将元组(1, 2)解构成x和y
    let [a, b] = [1, 2]; // 将数组[1, 2]解构成a和b
    let Point { x: x1, y: y1 } = Point { x: 1, y: 2 }; // 将结构体Point { x: 1, y: 2 }解构成x1和y1
    println!("{} {} {} {}", x, y, a, b); // 1 2 1 2
}
```

#### 解构式模式匹配

- 使用`_`来忽略不需要的值

- 例:
```rust
fn main() {
    let (x, _, y) = (1, 2, 3); // 将元组(1, 2, 3)解构成x和y, 忽略中间的2
    let [a, _, b] = [1, 2, 3]; // 将数组[1, 2, 3]解构成a和b, 忽略中间的2
    let Point { x: x1, y: _ } = Point { x: 1, y: 2 }; // 将结构体Point { x: 1, y: 2 }解构成x1, 忽略中间的y
    println!("{} {} {} {}", x, y, a, b); // 1 3 1 3
}
```

### 变量和常量的差异

- 常量名一般使用大写字母, 用下划线分割单词
- 常量可以在任何作用域中声明, 包括全局作用域, 而变量只能在特定作用域(函数, 代码块)中声明
- 常量不允许使用mut关键字, 也就是说常量是不可变的
- 使用`const`关键字来定义常量, 而且值的类型必须标注(不像变量可以自动推导类型)

- 常量在整个程序的生命周期中都是有效的, 适合用来定义一些全局的常量, 比如玩家的最大生命值

- 例:
```rust
fn main() {
    // 定义常量MAX_POINTS, 值为100_000, 类型为u32 
    // u32是无符号32位整数, 也就是正整数
    // 100_000是100000的简写, 用下划线来分割数字, 方便阅读
    const MAX_POINTS: u32 = 100_000; 
    println!("{}", MAX_POINTS); // 100000
}
```

### 变量的作用域

- 变量的作用域是指变量在程序中有效的范围
- 变量的作用域是由变量声明的位置决定的
- 变量的作用域是从声明的位置开始, 到当前作用域结束为止
- 例:
```rust
fn main() {
    let x = 5; // x的作用域从这里开始
    println!("{}", x); // 5
    let x = 6; // x的作用域从这里开始
    println!("{}", x); // 6
} // x的作用域到这里结束
```

### 隐藏

- 变量的作用域是从声明的位置开始, 到当前作用域结束为止
- 但是如果在当前作用域中声明了同名的变量, 那么新声明的变量会隐藏之前的变量

- 例:
```rust
fn main() {
    let x = 5; // x的作用域从这里开始
    println!("{}", x); // 5
    let x = 6; // x的作用域从这里开始
    println!("{}", x); // 6
    let x = 7; // x的作用域从这里开始
    println!("{}", x); // 7
} // x的作用域到这里结束
```

### 变量的可见性(变量遮蔽(shadowing))

- Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的

- 变量遮蔽的用处在于
    - 如果你在某个作用域内无需再使用之前的变量(在被遮蔽后，无法再访问到之前的同名变量), 就可以重复的使用变量名字, 而不用绞尽脑汁去想更多的名字


- 例:
```rust
fn main() {
    let x = 5; // 5 绑定到 x
    let x = x + 1; // 重复使用 let x = 来遮蔽 x 并取原来的值加 1
    { // 新的作用域 , 在这里修改的x不会影响到外面的x
        let x = x * 2; // 重复使用 let x = 来遮蔽 x 并取原来的值乘 2
        println!("{}", x); // 12
    } // x的可见性到这里结束
    println!("{}", x); // 6
} 
```
- 在以上代码中, 和mut不同, 第二个let生成了完全不同的新变量, 但是这个新变量的名字和之前的变量名字相同, 这就是变量遮蔽

- 变量遮蔽用处例:
```rust
fn main(){
    let spaces = "   "; // 3个空格
    let spaces = spaces.len(); // 3
    println!("{}", spaces); // 3
    // 这种结构是允许的
    // 因为第一个 spaces 变量是一个字符串类型, 第二个 spaces 变量是一个全新的变量且和第一个具有相同的变量名, 且是一个数值类型。
    // 所以变量遮蔽可以帮我们节省些脑细胞, 不用去想如 spaces_str 和 spaces_num 此类的变量名；
    // 相反我们可以重复使用更简单的 spaces 变量名。
}
```


## day3 基本类型

- rust每个值都有其确切的类型, 总的分为两类
    - 标量(基本)类型
        - 标量类型代表一个单独的值, 有四种基本的标量类型
            - 数值类型
                - 有符号整数 意思是可以表示正负数
                    - i的意思是integer, 也就是整数
                    - 有8位, 16位, 32位, 64位, 以及isize(指针位数)五种
                    - 8位的整数范围是-128~127
                    - 16位的整数范围是-32768~32767
                    - 32位的整数范围是-2147483648~2147483647
                    - 64位的整数范围是-9223372036854775808~9223372036854775807
                    - isize 视操作系统位数而定, 64位操作系统是64位, 32位操作系统是32位
                    - i8
                    - i16
                    - i32 
                    - i64
                    - isize
                - 无符号整数 意思是只能表示正数
                    - u的意思是unsigned, 也就是无符号
                    - 有8位, 16位, 32位, 64位, 以及usize(指针位数)五种
                    - 8位的整数范围是0~255
                    - 16位的整数范围是0~65535
                    - 32位的整数范围是0~4294967295
                    - 64位的整数范围是0~18446744073709551615
                    - usize 是视操作系统位数而定, 64位操作系统是64位, 32位操作系统是32位
                    - u8
                    - u16
                    - u32
                    - u64
                    - usize
                - 浮点数 意思是可以表示小数
                    - f32
                    - f64
                - 有理数 意思是可以表示分数
                    - isize
                    - usize
                - 复数 意思是可以表示虚数
                    - isize
            - 字符类型
                - 表示单个Unicode标量值的字符, 由单引号括起来, 如'a', 'b', 'c', 储存为4个字节
            - 字符串
                - 字符串字面量和字符串切片`&str` 
                    - 字符串字面量是由双引号括起来的字符串, 如"hello world", 储存为16个字节 
                    - 字符串切片是字符串的引用, 如&"hello world", 储存为8个字节
            - 布尔类型
                - `true`和`false` 
            - 单元类型
                - `()` , 也叫空元组, 唯一值也是`()`用来表示空值, 类似于其他语言中的`void`类型
    - 复合类型
        - 复合类型可以将多个值组合成一个类型, 有两种基本的复合类型
            - 元组
            - 数组

- 类型推导与标注
    - 与python和javascript不同, rust是静态类型语言, 所有的变量都必须标注类型, 也就是编译器在编译的时候就必须知道变量的类型
    - 并不意味着要每次都要手动标注类型, rust有类型推导, 也就是编译器可以根据变量的值来推导变量的类型
        - 在某些情况下, 编译器无法推导变量的类型, 这时候就需要手动标注类型
    - 推导案例:
        - ```rust
            fn main() {
                let x = 5; // rust可以根据5的值推导出x的类型是i32
                println!("{}", x); // 5
            }
            ```
    - 无法推导案例:
        - ```rust
            fn main() {
                let x; // rust无法推导出x的类型
                x = 5; // 所以这里需要手动标注类型
                println!("{}", x); // 5
            }
            ```
    - 显式标注案例:
        - ```rust
            fn main() {
                let x: i32 = 5; // rust可以根据5的值推导出x的类型是i32
                println!("{}", x); // 5
            }
            ```
    - 隐式标注案例:
        - ```rust
            fn main() {
                let x = 5i32; // rust可以根据5的值推导出x的类型是i32
                println!("{}", x); // 5
            }
            ```
    - rust的类型推导是非常智能的, 甚至可以推导出复杂的类型

### 数值类型

- rust中的数值类型分为两类
    - 整数类型
    - 浮点数类型

- rust使用一个相对传统的语法来创建整数(1,2, ...)和浮点数(1.0, 1.1, ...)
- 整数, 浮点数的运算和其他语言基本一致, 但是有一点需要注意, 就是整数的除法, 会自动向下取整

#### 整数类型

- rust中的整数类型分为两类
    - 有符号整数(integers) i 开头
        - 可以取正数, 0, 负数
    - 无符号整数(unsigned) u 开头
        - 只能取正数和0, 不能取负数
    - isize 和 usize 类型
        - 取决于程序运行的计算机 CPU 类型： 
            - 64 位架构上，它们是 64 位的
            - 32 位架构上，它们是 32 位的
        - 应用场景
            - 主要用于集合的索引
            - 当索引集合时，使用 usize
            - 当需要存储一个平台指针的时候，使用 isize

- **rust整型默认使用i32, 这是因为在大多数的机器上, i32是最快的, 即使是64位的机器也是如此**

- 整形字面量书写方式
    - 十进制
        - `98_222` // 以_分割数字, 方便阅读 数字: 98222
    - 十六进制
        - `0xff` // 0x开头 数字: 255
    - 八进制
        - `0o77`// 0o开头 数字: 63
    - 二进制
        - `0b1111_0000` // 0b开头 数字: 240
    - 字节(u8类型)
        - `b'A'` // b开头 数字: 65

- 整型溢出

- 意思是当整型的值超过了其类型所能表示的范围时, 会发生溢出, 也就是超过的部分会被截断
    - 比如有一个u8类型的整数, 范围是0~255, 如果给它赋值256, 那么就会发生溢出, 也就是256-256=0, 所以结果是0

- rust在`debug`模式下会检查溢出, 如果发生溢出, 会直接panic(崩溃, Rust使用这个术语来表示程序因为错误而退出)
- 当使用`--relesse`模式编译时, rust不会检查溢出, 但是会有警告, 并且溢出的结果是未定义的, 也就是说, 有可能是正确的, 也有可能是错误的
- 当检测出溢出时, rust会按照补码循环溢出(也叫二进制补码循环)的方式处理
    - 大于该类型最大值的数会被补码转换成该类型支持的对应数字最小值
    - 比如u8类型的最大值是255, 如果给它赋值256, 那么256变成0, 257变成1, 以此类推

- 显式处理可能的溢出, 可以使用标准库针对原始数字类型提供的这些方法
    - `wrapping_*` 方法在所有模式下都会进行溢出处理, 例如 `wrapping_add` 会在溢出时返回最小值, 而不是 panic
    - `checked_*` 使用此方法发生溢出时会返回 None
    - `overflowing_*` 会返回一个元组(该值, 是否存在溢出的布尔值), 元组的第一个元素是计算结果, 第二个元素是一个布尔值, 表示是否发生了溢出
    - `saturating_*` 方法使值达到该类型的最大值或最小值

- `wrapping_*` 方法案例:
```rust
fn main() {
    let x: u8 = 255;
    println!("{}", x.wrapping_add(2)); // 1
}
```

#### 浮点数类型

- rust中的浮点数类型分为两类
    - f32
    - f64

- 默认为f64, 在现代CPU中, f64和f32的运算速度是一样的, 但是f64的精度更高

- 浮点数字面量书写方式
    - 小数点
        - `3.14` // 数字: 3.14
    - 科学计数法
        - `2.0e+2` // 数字: 200.0
        - `2.0e-2` // 数字: 0.02
        - `2e2` // 数字: 200.0
        - `2e-2` // 数字: 0.02

- 浮点数根据IEEE-754标准实现, f32是单精度浮点数, f64是双精度浮点数
    - 单精度浮点数意思是使用32位来表示一个浮点数
    - 双精度浮点数意思是使用64位来表示一个浮点数
    - 区别在于, 双精度浮点数的精度更高, 但是占用的内存更多

- 例:
- ```rust
    fn main() {
        let x = 2.0; // f64
        let y: f32 = 3.0; // f32
        println!("{}", x); // 2
        println!("{}", y); // 3
    }
    ```

- 浮点数陷阱
    - 浮点数由于底层格式的特殊性, 不能用来进行精确的计算, 主要两个原因
        - 1. 浮点数的位数有限, 所以计算机无法表示无限的小数, 所以浮点数只能表示一个近似值
        - 2. 浮点数的运算速度很快, 但是精度有限, 所以浮点数的运算结果也只能是一个近似值
    - 避免浮点数陷阱的方法
        - 1. 避免在浮点数上测试相等性
        - 2. 当结果在数学上可能存在未定义时，需要小心检查
    - 例:
        - ```rust
            fn main() {
                let x = 0.1 + 0.2; // 0.30000000000000004
                println!("{}", x); // 0.30000000000000004
                println!("{}", x == 0.3); // false
            }
            ```

- NaN

- NaN是一个特殊的浮点数, 代表非数字(not a number), 用来表示一个无效的浮点数

- **所有跟`NaN`交互的操作, 都会返回一个`NaN`, 而且`NaN`不能用来比较**

- 例:
    - ```rust
        fn main() {
            let x = (-1.0_f32).sqrt(); // -1.0
            println!("{}", x); // NaN
        }
        ```
    - 出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN:
    - ```rust
        fn main() {
            let x = (-1.0_f32).sqrt(); // -1.0
            if x.is_nan() {
                println!("未定义的数学行为"); // 未定义的数学行为
            }
        }
        ```

#### 数字运算

- rust中的数字运算和其他语言基本一致, 但是有一点需要注意, 就是整数的除法, 会自动向下取整
- 普通加,减,乘,除,求余(取模)例:
    - ```rust
        fn main() {
            let x = 5 + 5; // 10
            let y = 5 - 5; // 0
            let z = 5 * 5; // 25
            let w = 5 / 5; // 1
            println!("{} {} {} {}", x, y, z, w); // 10 0 25 1
        }
        ```

- 综合示例
    - ```rust
        fn main() {
            // 编译器会进行自动推导，给予twenty i32的类型
            let twenty = 20;
            // 类型标注
            let twenty_one: i32 = 21;
            // 通过类型后缀的方式进行类型标注：22是i32类型
            let twenty_two = 22i32;

            // 只有同样类型，才能运算
            let addition = twenty + twenty_one + twenty_two;
            println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

            // 对于较长的数字，可以用_进行分割，提升可读性
            let one_million: i64 = 1_000_000;
            println!("{}", one_million.pow(2)); // pow是求幂函数,参数是幂次方

            // 定义一个f32数组，其中42.0会自动被推导为f32类型
            let forty_twos = [
                42.0,
                42f32, 
                42.0_f32,
            ];

            // 打印数组中第一个值，并控制小数位为2位
            println!("{:.2}", forty_twos[0]);
        }
        ```

#### 位运算

- 位运算也就是二进制运算, 有六种基本的位运算
    - 与(&)
        - 相同位置都是1, 结果为1, 否则为0
        - 例:
            - ```rust
                fn main() {
                    // 0b 是二进制的标识符
                    let x = 0b1010; // 10 二进制: 1010
                    let y:i32 = 12; // 12 二进制: 1100
                    let z = x & y; // 8 二进制: 1000
                    println!("{}", z); // 8
                }
                ```
    - 或(|)
        - 相同位置只要有一个1, 结果为1, 否则为0
        - 例:
            - ```rust
                fn main() {
                    // 0b 是二进制的标识符
                    let x = 0b1010; // 10 二进制: 1010
                    let y:i32 = 12; // 12 二进制: 1100
                    let z = x | y; // 14 二进制: 1110
                    println!("{}", z); // 14
                }
                ```
    - 异或(^)
        - 相同位置不同, 结果为1, 否则为0
        - 例:
            - ```rust
                fn main() {
                    // 0b 是二进制的标识符
                    let x = 0b1010; // 10 二进制: 1010
                    let y:i32 = 12; // 12 二进制: 1100
                    let z = x ^ y; // 6 二进制: 0110
                    println!("{}", z); // 6
                }
                ```
    - 取反(!)
        - 把位中的0变成1, 1变成0
        - 例:
            - ```rust
                fn main() {
                    // 0b 是二进制的标识符
                    let x = 0b1010; // 10 二进制: 1010
                    let z = !x; // -11 二进制: 11111111111111111111111111110101
                    println!("{}", z); // -11
                }
                ```
    - 左移(<<)
        - 所有位向左移动指定位数, 右位补0
        - 例:
            - ```rust
                fn main() {
                    // 0b 是二进制的标识符
                    let x = 0b1010; // 10 二进制: 1010
                    let z = x << 1; // 20 二进制: 10100
                    println!("{}", z); // 20
                }
                ```
    - 右移(>>)
        - 所有位向右移动指定位数, 带符号移动(正数补0, 负数补1)
        - 例:
            - ```rust
                fn main() {
                    // 0b 是二进制的标识符
                    let x = 0b1010; // 10 二进制: 1010
                    let z = x >> 1; // 5 二进制: 101
                    println!("{}", z); // 5
                }
                ```

#### 序列

- rust 提供了一个连续生成数字或字符的语法，称为序列（range）
- 序列的语法是 `start..end`，其中 start 是起始值，end 是结束值
- 序列是一个左闭右开的区间，也就是说，包含起始值，不包含结束值
- 不包含结束值
    - 例:
        - ```rust
            fn main() {
                // 0..5 生成的序列是 0, 1, 2, 3, 4
                for i in 0..5 {
                    println!("{}", i); // 0 1 2 3 4
                }
            }
            ```
- 包含结束值
    - 例:
        - ```rust
            fn main() {
                // 0..=5 生成的序列是 0, 1, 2, 3, 4, 5
                for i in 0..=5 {
                    println!("{}", i); // 0 1 2 3 4 5
                }
            }
            ```

- 字符串序列
    - 例:
        - ```rust
            fn main() {
                // 'a'..'z' 不包括 'z'
                for i in 'a'..'z' {
                    println!("{}", i); // a b c d e f g h i j k l m n o p q r s t u v w x y
                }
            }
            ```

#### 有理数和复数

- Rust的标准库入门门槛较高, 因此有理数和复数未包含在标准库中
    - 有理数和复数
    - 任意大小的整数和任意精度的浮点数
    - 固定精度的十进制小数, 常用于货币相关场景
- 社区高质量Rust数值库: num
    - 引入步骤
        - 在 `Cargo.toml` 中的 `[dependencies]`下添加一行 num = "版本号" 
        - 在 `main.rs` 中添加 `extern crate num;` 意思是引入num库

#### 总结
- Rust拥有相当多的数值类型, 因此要熟悉这些类型所占的内存大小, 这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数

- 类型转换必须是显式的, 也就是说, 你必须使用 `as` 关键字来进行类型转换, Rust永远也不会偷偷把你的16bit整数转换成32bit整数, 除非你明确的告诉它这么做

- Rust的数值上可以使用方法, 例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`, 在这里我们使用了`类型后缀`，因为编译器需要知道 13.14 的具体类型

### 字符, 布尔, 单元类型

#### 字符类型(char)

- Rust中字符类型不只是ASCII字符, 它可以表示任何Unicode标量值, 也就是说, 它可以表示任何字符: emoji表情, 中文, 日文, 韩文等等
    - 例:
    - ```rust
        fn main() {
            let cn = '晴'; // 中文
            let jp = 'はれ'; // 日文
            let kr = '맑음'; // 韩文
            let en = 'sunny'; // 英文
            let emoji = '🎉'; // emoji表情
            println!("{} {} {} {}", cn, jp, kr, en, emoji); // 晴 はれ 맑음 sunny 🎉
        }
        ```
- Unicode值范围是从`U+0000`到`U+D7FF`和`U+E000`到`U+10FFFF`之间的值
- Unicode标量值是一个32位的值, 也就是4个字节
    - ```rust
        fn main() {
            let x = '晴';
            println!("字符'晴'占用了{}字节的内存大小",std::mem::size_of_val(&x));
            // 字符'晴'占用了4字节的内存大小
        }
        ```

#### 布尔类型

- 布尔类型只有两个值, `true`和`false`
- 主要应用场景为流程控制

#### 单元类型

- 单元类型也叫空元组, 唯一值也是`()`用来表示空值, 类似于其他语言中的`void`类型

- 例:
    - ```rust
        fn main() { // main函数的返回值类型是单元类型, 并不是无返回值
            let x = (); // 单元类型
            println!("{:?}", x); // 常见的println!宏的返回值类型是单元类型
        }
        ```

- 可以用`()`作为 map 的值，表示我们不关注具体的值，只关注 `key` 这种用法和 `Go` 语言的 `struct{}` 类似，可以作为一个值用来占位，但是完全不占用任何内存空间


### 语句与表达式

#### 讲解
- rust的函数体由一系列的语句和表达式组成, 语句和表达式是rust的两个基本概念
    - 例:
        - ```rust
            fn main(x: i32, y: i32) -> i32 { // -> i32 表示返回值类型是i32
                let x = x + 1; // 语句
                let y = y + 5; // 语句
                x + y // 表达式
            }
            ```
- 语句和表达式的区别
    - 语句执行操作, 但是不返回值, 分号结尾
    - 表达式计算并产生一个值并返回, 不需要分号结尾
    - 表达式绝对不能以分号结尾, 如果以分号结尾, 那么就变成了语句, 语句不返回值, 所以会报错

- 对于Rust而言, `语句(statement)`和`表达式(expression)`的方式是非常重要的, 需要**明确区分这两个概念**, 因为它们在Rust中有着不同的用法, 对于其他语言而言, 这两个概念往往无需区分。
- 基于表达式的函数式语言的总要特征, **表达式总要返回值**

- 表达式可以是语句的一部分, 但是语句不能是表达式的一部分

- 表达式即使不返回任何值,也会隐式的返回一个单元类型的值`()`

#### 语句例

- ```rust
    fn main() {
        let x = 5; 
        let y = 6; 
        let z = x + y; // 语句, 但是这里的x + y是一个表达式
        println!("{}", z); // 语句
    }
    ```


#### 表达式例

- ```rust
    fn main() {
        let x = 5; // 5
        let y = { // 语句块表达式
            let x = 3; // 3
            x + 1 // 4
        }; // 6
        println!("{}", x); // 5
        println!("{}", y); // 6
    }
    ```

### 函数

- 要点
    - 函数名和变量名都用蛇形命名法
    - 函数的位置可以随便放, 只要定义了就可以, 一般放在main函数的上面
    - 函数的参数都需要标注类型

#### 函数参数

- 因为Rust是强类型语言, 所以函数的参数都需要标注类型
    - 例:
        - ```rust
            fn main() {
                another_function(5, 6.1);
            }

            fn another_function(x: i32, y: f32) {
                println!("The value of x is: {}", x);
                println!("The value of y is: {}", y);
            }
            ```

- 函数参数如果有一个参数标注了类型, 那么其他参数也必须标注类型, 否则会报错

#### 函数返回

- 函数就是表达式, 所以可以直接把函数的返回值赋给调用者
- 函数的返回值就是最后一条表达式的返回值, 也可以提前return返回

- 例:
    - ```rust
        fn plus_or_minus(x:i32) -> i32 {
            if x > 5 {
                return x - 5
            }

            x + 5
        }

        fn main() {
            let x = plus_or_minus(5);

            println!("The value of x is: {}", x);
        }
        ```
    - 两个重点:
        - `let x = plus_five(5);` 说明用一个函数的返回值来初始化`x`变量, 这种写法等同于`let x = 5 + 5`;

- 无返回值
    - 函数没有返回值, 那么返回一个`()`
    - 通过`;`结尾的语句返回一个`()`
    - 隐式返回一个`()`例:
        - ```rust
            use std::fmt::Debug;
            // std::fmt::Debug 作用是让我们可以使用 {:?} 打印任意类型的值
            fn report<T: Debug>(item: T) {
                // T: Debug 表示 T 必须实现 Debug trait
                // item: T 表示 item 的类型是 T
                // <> 中的内容是泛型参数 , 泛型用于表示抽象类型
                // () 中的内容是函数参数
                println!("{:?}", item);
            }
            report("hello"); // "hello"
            ```
    - 显式返回一个`()`例:
        - ```rust
            fn clear(text: &mut String) -> () {
                *text = String::from("");
            }

            // text: &mut String 表示 text 是一个可变的字符串引用
            // -> () 表示返回一个单元类型的值
            // *text = String::from(""); 表示将 text 指向的字符串清空
            // 显式返回一个 ()，这样就可以在函数调用的时候，使用 let x = clear(&mut text); 这样的形式
            ```

#### 永不返回的发散函数`!`

- 当用`!`作函数返回类型的时候, 表示函数永不返回(diverge function) 这种语法往往用做会导致程序崩溃的函数:

```rust
fn dead_end() -> ! {
    panic!("你已经到了穷途末路，崩溃吧！");
}
```

下面的代码创建了一个无限循环, 该循环永不跳出, 因此函数也永不返回:

```rust
fn main() -> ! {
    let mut x = 0; //语句
    loop {
        x += 1 // 表达式
    };
}
```

## day4 所有权和借用

### 所用权

所有程序都需要和内存打交道, 如何从内存中申请空间存放内容, 如何不需要时将其释放, 如何避免重复使用同一块内存空间, 这些都是需要的问题

- 三种方案:
    - 垃圾回收机制(GC) 在程序运行时不断寻找不再使用的内存, 并释放它们, 典型代表是Java, C#, GO
    - 手动管理内存, 在程序运行时自己管理内存, 申请内存, 使用内存, 释放内存
    - 所有权系统, 在编译时通过一系列规则, 让编译器在编译时检查内存的使用情况, 以此来保证内存的安全

- Rust选择了第三种方案, 所有权系统, 也是Rust的核心特性
- 检查只发生在编译期, 不会影响性能

### 栈(Stack)和堆(Heap)

栈和堆是最核心的数据结构, 也是所有编程语言都会涉及到的概念

栈和堆的核心目标就是为程序运行时提供内存空间, 但是它们的实现方式不同

#### 栈(Stack)

- 栈按照顺序存储值并以`相反`顺序取出值, 这也被称为`后进先出`(LIFO, Last-In-First-Out), 就像一摞盘子, 最后放上去的盘子最先被取下来

- 栈中的所有数据必须占用`已知且固定`的大小

- 增加数据到栈中叫做`入栈`, 减少数据的操作叫做`出栈`

#### 堆(Heap)

与栈不同, 堆是用来存放在编译时未知大小或大小可能变化的数据

堆是一个`分配一些内存空间`的运行时操作

堆中的数据可以按照任意顺序访问

当向堆放入数据时, 操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针, 该过程被称为`在堆上分配内存`，简称为 “分配”(allocating)。

该指针会被堆入**栈**中，因为该指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据

简单叙述为: 将数据放入这块空间，并将指针存储在栈上

- 由上述描述可知
    - 堆是缺乏组织的数据结构, 形象表示就像: 去餐厅, 告知服务员几个人, 然后服务员找到一个够大的空桌子(`堆上分配内存`), 并领你们去座位(`将指针存储在栈上`), 后续如果有人想找你们, 可以通过桌号(`栈上的指针`)来找人

#### 性能区别

- 栈上的数据可以快速读取, 因为数据是连续存储的, 而且栈上的数据大小是固定的, 所以不需要额外的工作

- 栈上分配内存比堆上分配内存快
    - 入栈时无需函数调用或系统调用来分配新空间, 只需要数据放入栈顶即可
    - 堆上分配内存时, 需要在堆上找到一块足够大的空间, 并将指针存储在栈上, 这个过程需要做一些记录为下一次分配做准备, 如果堆上没有足够大的空间, 那么就需要更慢的系统调用申请内存

#### 所有权与堆栈

- 当代码调用一个函数时, 传递给函数的参数(包括可能指向堆上数据的指针和函数的局部变量) 依次被压入栈中, 这些值将被从栈中按照相反的顺序依次移除

- 因为堆上数据缺乏组织, 因此跟踪这些数据何时分配和释放是非常重要的, 为了解决这个问题, Rust通过所有权系统来管理堆上的数据

- 在 Rust 中, 明白堆栈的原理, 对于理解所有权的工作原理会有很大的帮助


### 所有权原则

    1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者（owner）
    2. 值在任一时刻有且只有一个所有者
    3. 当所有者（变量）离开作用域，这个值将被丢弃(drop)

#### 变量作用域

- 作用域是一个变量在程序中有效的范围

- 案例讲解
    - ```rust
        fn main() {
            let s = "hello"; // s的作用域从这里开始
            println!("{}", s); 
        } // s的作用域从这里结束
        ```

#### 简单介绍String类型

- 字符串字面值 `let s ="hello"`, `s` 是一个指向字符串值的指针, 字符串字面值是硬编码在程序中的, 所以它是不可变的, 不适用于所用场景，有两个原因:
    - 1. 字符串字面值是硬编码在程序中的, 所以它是不可变的
    - 2. 并非所有字符串的值都能在编写代码时得知

- Rust中的字符串类型有两种
    - 字符串切片`&str`
    - 字符串`String`

例如, 字符串是需要程序运行时, 通过用户动态输入然后存储在内存中的, 这种情况下, 字符串字面值是无法满足需求的, 因此Rust提供了`String`类型, 该类型存储在堆上, 允许存储一个可变长度的UTF-8编码的文本

- `::`是一种调用操作符, 它允许你命名一个关联函数, 这个关联函数是一个特定类型的函数, 而不是某个实例的函数

- 创建String类型的方法
    - 使用`from`方法
        - ```rust
            let s = String::from("hello");
            // 这里::表示调用 String 模块中的 from 方法
            s.push_str(", world!"); // push_str() 方法向字符串追加字面值
            ```
    - 使用`to_string`方法
        - ```rust
            let s = "hello".to_string();
            ```




